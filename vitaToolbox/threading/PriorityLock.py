#*****************************************************************************
#
# PriorityLock.py
#
#
#
#*****************************************************************************
#
#
# Copyright 2013-2022 Sighthound, Inc.
#
# Licensed under the GNU GPLv3 license found at
# https://www.gnu.org/licenses/gpl-3.0.txt
#
# Alternative licensing available from Sighthound, Inc.
# by emailing opensource@sighthound.com
#
# This file is part of the Sighthound Video project which can be found at
# https://github.com/sighthoundinc/SighthoundVideo
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; using version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111, USA.
#
#
#*****************************************************************************

import threading

class PriorityLock(object):
    """ Custom lock which allows acquisition by priority and also in the order
    of the acquisition calls being made.
    """

    ###########################################################
    def __init__(self):
        """ Constructor.
        """
        self._cond = threading.Condition()
        # to identify the position in the queue every candidate carries a number
        # which is generated by a global counter
        self._counter = 0
        # (number,priority) entries in, ascending by priority
        self._queue = []
        # to detect if a thread has acquired the lock (stores the number)
        self._acquired = None

    ###########################################################
    def acquire(self, priority):
        """ Acquires the lock, blocks until this happened.

        @param  priority  An integer determining the priority (ascending).
        @return           The acquisition number. Needs to be passed back on
                          release.
        """
        self._cond.acquire()
        try:
            # everyone gets a number
            number = self._counter
            self._counter += 1

            # if nothing's going on we own the lock immediately
            if self._acquired is None:
                self._acquired = number
                return number

            # search the queue for the the correct spot, which is right behind
            # the last slot with the same priority
            pos = 0
            while pos < len(self._queue):
                slot = self._queue[pos]
                if slot[1] < priority:
                    pos += 1
                    continue
                # we found our spot and get in line
                self._queue.insert(pos, (number, priority))
                break
            if pos == len(self._queue):
                # we're next (at least at this moment)
                self._queue.append((number, priority))

            # now wait until the lock-owning thread releases the lock
            while True:
                self._cond.wait()
                # is the lock available and is it also our turn?
                if self._acquired is None and number == self._queue[-1][0]:
                    self._acquired = number
                    self._queue.pop()
                    return number
                continue
        finally:
            self._cond.release()

    ###########################################################
    def release(self, number):
        """ Released the lock.

        @param  number  The acquisition number. An exception is thrown if the
                        number does not match, meaning if the thread actually
                        does not hold the lock (serious) or if has released it
                        already (less serious, but still).
        """
        self._cond.acquire()
        try:
            if number != self._acquired:
                raise Exception("wrong release number (%d!=%d)" %
                                (number, self._acquired))
            self._acquired = None
            self._cond.notifyAll()
        finally:
            self._cond.release()
