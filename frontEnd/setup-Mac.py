#*****************************************************************************
#
# setup-Mac.py
#
#
#
#*****************************************************************************
#
#
# Copyright 2013-2022 Sighthound, Inc.
#
# Licensed under the GNU GPLv3 license found at
# https://www.gnu.org/licenses/gpl-3.0.txt
#
# Alternative licensing available from Sighthound, Inc.
# by emailing opensource@sighthound.com
#
# This file is part of the Sighthound Video project which can be found at
# https://github.url/thing
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; using version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111, USA.
#
#
#*****************************************************************************

"""
This is a setup.py script generated by cxfreeze-quickstart, via

    'cxfreeze-quickstart'

This script has been hand-edited, so do not automatically generate it
again.  Instead, modify it by hand based on instructions found here:

    https://cx-freeze.readthedocs.org/en/latest/distutils.html

Usage to build an application bundle (.app) for Mac OS X:
    ./run python frontEnd/setup-Mac.py bdist_mac

Usage to build an application bundle (.app) and installer (.dmg) for Mac OS X:
    ./run python frontEnd/setup-Mac.py bdist_dmg
"""

# Python imports...
import sys
import os
import shutil
import plistlib
from pprint import pformat
from glob import glob

# Local imports...
from appCommon.CommonStrings import kAppName, kExeName, kSighthoundCompanyName
from appCommon.CommonStrings import kVersionString, kCopyrightYear
from appCommon.CommonStrings import kBundleIdentifier, kMinMacOSVersion
from appCommon.CommonStrings import kWebcamExeName


# CxFreeze gets easily confused by names with spaces. Just replace spaces with
# underscores for now, and we'll replace them back later, after bundling is
# finished.
BUNDLE_NAME = kAppName.replace(' ', '_')

# We need to tell cxFreeze all of the libs we want it to package. So we walk
# through every directory looking for libs to package up, and exclude searching
# in some directories that we don't care about.
EXCLUDED_LIBRARY_DIRS = {
    os.path.abspath('.'): ['sio'],
}

filenameToFilepath = {}
LIBRARIES = []
for rootdir, dirs, files in os.walk(os.path.abspath('.')):
    for filename in files:
        filepath = os.path.join(rootdir, filename)
        if filename.endswith('.dylib'):
            filenameToFilepath[filename] = filepath
            LIBRARIES.append((filepath, filename))
    for exclude_dir in EXCLUDED_LIBRARY_DIRS.get(rootdir, []):
        dirs.remove(exclude_dir) if exclude_dir in dirs else None


# Include some extra files that don't end in .dylib...
INCLUDE_FILES = LIBRARIES + [
]

ICON_FILE = 'icons/SmartVideoApp.icns'

# This is where the .app file will be moved when cxFreeze is finished bundling.
TARGET_DIR = '../../../app-out/FrontEnd-Mac'

# CxFreeze wants a description for the app, but we leave it blank, because
# it's not needed.
DESCRIPTION = ''

# The 'main' script of the app.
APP = 'FrontEndLaunchpad.py'

# This is for data files, but we already copy all our resources to the .app file
# after bundling; so this is empty.
DATA_FILES = []

# CxFreeze doesn't make the best plist file in the world, so we have to make one
# ourselves to get what we want. The plist below is a peice of the plist file
# from our app when it was packaged by py2app.
PLIST_FILENAME = 'Info.plist'
PLIST = {
    # TODO: What is this?  I copied this here because it was in our py2app
    # configuration-setup file, but I'm not sure if we need this anymore.
    #'CFBundleDocumentTypes': [dict(CFBundleTypeExtensions=["pan"],
    #    CFBundleTypeName="%s Project" % kAppName,
    #    CFBundleTypeRole="Editor",
    #    CFBundleTypeIconFile="VitaminDToolkitProjectFile.icns"),
    #],
    'LSEnvironment' : {
        'OBJC_DISABLE_INITIALIZE_FORK_SAFETY':'YES'
    },
    'CFBundleDevelopmentRegion': 'English',
    'CFBundlePackageType': 'APPL',
    'CFBundleExecutable': kExeName,
    'CFBundleIconFile': ICON_FILE,
    'CFBundleIdentifier': kBundleIdentifier,
    'CFBundleVersion': kVersionString,
    'CFBundleShortVersionString': kVersionString,
    'CFBundleGetInfoString': kAppName + ' ' + kVersionString + \
                             ' Copyright ' + kCopyrightYear + ' ' + \
                             kSighthoundCompanyName,
    'NSHumanReadableCopyright': 'Copyright ' + kCopyrightYear + \
                                ' ' + kSighthoundCompanyName,
    'LSMinimumSystemVersion': os.getenv("MACOSX_DEPLOYMENT_TARGET", kMinMacOSVersion),
    'NSHighResolutionCapable': True,
    'NSCameraUsageDescription' : 'Sighthound Video needs access to local camera (optional)'
}
plistlib.writePlist(PLIST, PLIST_FILENAME)

# Dependencies are automatically detected, but it might need fine tuning.
BUILD_EXE_OPTIONS = {

    # Include all of the libraries that cxFreeze needs to copy into the bundle.
    'include_files': INCLUDE_FILES,

    # binaries and dylibs to exclude when searching for dependencies.
    'bin_excludes': [

        # We build this file ourselves, but we exclude it from the search and
        # include it manually in 'include_files' because cx_Freeze will try to
        # pull this file from "/opt/X11/lib" on some developer machines.
        'libfreetype.6.dylib',
    ],

    # This is needed so that python files are imported using relative paths
    # and not absolute paths. If this was not here, python scripts in the
    # frozen app would not be able to import our local python scripts.
    'replace_paths': [('*' , ''),],

    # Optimize python code.
    'optimize': 1,

    # Modules that we need to exclude.
    'excludes': [

        # We don't use tkinter.  It's harmless to keep it, but this error is
        # observed when it's included:
        # '/Library/Frameworks/Tcl.framework/Versions/8.4/Tcl' and
        # '/Library/Frameworks/Tk.framework/Versions/8.4/Tk' cannot be found
        # or don't exist.
        # We exclude both spellings of the word 'tkinter' because it can show up
        # as either one, depending on system version.  Just exclude both to be
        # safe.
        'Tkinter',
        'tkinter',
        # https://www.reddit.com/r/learnpython/comments/4rjkgj/no_file_named_sys_for_module_collectionssys/
        'collections.abc',
    ],

    # If there are modules that need to be removed, but other modules in the
    # _same_ package need to be included, treat the package as a namespace
    # package so that the exclude/include won't confuse cxFreeze. Example:
    # if foo.bar is needed, but we want to exclude foo.baz, make sure to declare
    # foo as a namespace package. Otherwise, cx_Freeze will completely exclude
    # foo from its searches for the includes.
    # 'namespace_packages': [
    #
    # ],

    # Modules that we need to include because cxFreeze missed them, or because
    # it has no way of finding out that we need them.
    'includes': [
        'netifaces',
    ],

    # Include a module with all of its submodules.
    'packages': [
        'OpenGL',
        'PIL',
        'pyaudio',
        'requests',
        'wx',
        'wx.adv',
        'wx._adv',
        #'OpenGL.platform',
    ],
}

# This is where we specify MacOS app-specific options.
BUILD_MAC_OPTIONS = {
    'custom_info_plist': PLIST_FILENAME,
    'iconfile': ICON_FILE,
    'bundle_name': BUNDLE_NAME,
}

# This is where we specify MacOS dmg-specific options.
BUILD_DMG_OPTIONS = {
    'applications_shortcut': True,
}

# Organize all of the options together for cxFreeze.
OPTIONS = {
    'build_exe': BUILD_EXE_OPTIONS,
    'bdist_mac': BUILD_MAC_OPTIONS,
    'bdist_dmg': BUILD_DMG_OPTIONS,
}


# Third party imports...
import cx_Freeze

# There's some monkey patching going on here, because without it cxFreeze is
# unable to find dependent .so and .dylib files. Specifically, cxFreeze does
# intelligently find bin and lib dependencies of python extensions, BUT when
# it goes to _find_ and _copy_ the dependency, it assumes that the dependency
# will be located in the paths shown by by "otool -L python_extension_here.so".
# This might work well for many dependencies, but it won't work for dependencies
# that have no paths in front of the dependency's file name. For example, when
# "otool -L cv2.so" is run, "libopencv_core.dylib" is listed. So cxFreeze tries
# to copy this file without a path (because there was no path listed with the
# dependency), which gives a "file not found or does not exist" error. To fix
# this, whenever we see a dependency with no path to it, we assume it's in the
# same directory as the file that had "otool -L" used on it.
_GetDependentFilesOriginal = cx_Freeze.Freezer._GetDependentFiles #cx_Freeze.Freezer._GetDependentFiles

def _GetDependentFiles(self, sourcePath):

    # First get the dependencies from the original cx_Freeze private function...
    originalDependencies = _GetDependentFilesOriginal(self, sourcePath)

    # Get the directory that contains the source file...
    sourceDir = os.path.dirname(sourcePath)

    # Our new (possibly) modified list of depencies for this source file that
    # we will return.
    dependencies = []

    # A dict with key=sourcePath and value=dependency where the values are
    # dependencies that could not be found.
    filesNotFound = {}

    for dependency in originalDependencies:

        # If the file exists, make sure that it is prepended with an absolute
        # path just to be paranoid...
        if os.path.isfile(dependency):
            dependencies.append(os.path.abspath(dependency))
            continue

        depFilename = os.path.basename(dependency)

        # The file doesn't exist; check if it exists in the source file's
        # directory as a relative path...
        newDepPath = os.path.join(sourceDir, dependency)
        if os.path.isfile(newDepPath):
            dependencies.append(os.path.abspath(newDepPath))
            continue

        # The file doesn't exist; check if it exists in the source file's
        # directory directly...
        newDepPath = os.path.join(sourceDir, depFilename)
        if os.path.isfile(newDepPath):
            dependencies.append(os.path.abspath(newDepPath))
            continue

        # Still no luck; as a last resort, let's see if we've seen the file
        # before in our search for dylibs above...
        if filenameToFilepath.has_key(depFilename):
            dependencies.append(os.path.abspath(filenameToFilepath[depFilename]))
            continue

        # We should never really reach this point, so let's keep track of the
        # source file and the dependency that we couldn't find to report it
        # later...
        filesNotFound[sourcePath] = dependency

    # Report our missing dependencies...
    if filesNotFound:
        print(
            "=== DEPENDENCIES NOT FOUND === \n" +
            pformat(filesNotFound)
        )

    return dependencies

# Do our monkey patch...
cx_Freeze.Freezer._GetDependentFiles = _GetDependentFiles

# Import cx_Freeze.setup and cx_Freeze.Executable *_AFTER_* the monkey patch
# just in case they instantiate the Freezer related classes that use our patch.
from cx_Freeze import setup, Executable


# GUI applications require a different base on Windows (the default is for a
# console application).
base = None
if sys.platform == 'win32':
    base = 'Win32GUI'


################################################################################
def main():

    executables = [
        Executable(
            APP,
            base=base,
            targetName=kAppName,
        ),
    ]

    print("Options=%s" % str(OPTIONS))

    setup(
        name = kAppName.replace(' ', '_'),
        version = kVersionString.replace(' ', '_'),
        description = DESCRIPTION,
        options = OPTIONS,
        executables = executables,
    )

    # For some reason, we can't seem to specify a target directory for our app,
    # so we let cxFreeze do its thing, then we copy the app to the target
    # directory ourselves.
    sourcePath = os.path.abspath(os.path.join('.', 'build', BUNDLE_NAME + '.app'))
    destinationPath = os.path.abspath(os.path.join(TARGET_DIR, kAppName + '.app'))
    print('Moving App %s --> %s' % (sourcePath, destinationPath))
    shutil.move(sourcePath, destinationPath)

    # This is a list of file we need to manually move as

################################################################################
if __name__ == '__main__':
    try:
        main()
    except:
        import traceback
        print(
            "Exception while executing cxFreeze script!! " +
            traceback.format_exc()
        )
        sys.exit(-1)
